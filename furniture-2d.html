<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2D 가구배치 프로토타입</title>
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <style>
    :root{
      --bg:#0b1220;
      --panel:rgba(255,255,255,.03);
      --line:rgba(255,255,255,.10);
      --text:#e8eefc;
    }
    body{ margin:0; font-family:system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; background:var(--bg); color:var(--text); }
    .wrap{ display:grid; grid-template-columns:320px 1fr; height:100vh; }
    .panel{ padding:14px; border-right:1px solid var(--line); background:var(--panel); overflow:auto; }
    .panel h2{ font-size:14px; margin:0 0 10px; opacity:.92; }
    .hint{ font-size:12px; opacity:.75; line-height:1.4; }
    .kv{ display:grid; grid-template-columns:110px 1fr; gap:8px; align-items:center; margin:8px 0; }
    .row{ display:flex; gap:8px; flex-wrap:wrap; margin:10px 0; }
    button, select, input, textarea{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:8px 10px;
      border-radius:10px;
      font-size:12px;
      outline:none;
    }
    button{ cursor:pointer; }
    button:hover{ background:rgba(255,255,255,.10); }
    textarea{ width:100%; height:180px; resize:vertical; }
    .stageWrap{ position:relative; overflow:auto; }
    .topbar{
      position:absolute; left:10px; top:10px; z-index:10;
      background:rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.10);
      border-radius:12px; padding:8px 10px; backdrop-filter: blur(6px);
      font-size:12px;
    }
    .badge{ display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.15); margin-left:8px; opacity:.9; }
    .danger{ border-color: rgba(255,90,90,.55) !important; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <h2>2D 가구배치 (프로토타입)</h2>

      <div class="kv">
        <div>스케일</div>
        <div>
          <input id="pxPerCm" type="number" value="4" min="1" step="1" style="width:90px" />
          <span class="hint">px / cm</span>
        </div>
      </div>

      <div class="kv">
        <div>격자 스냅</div>
        <div>
          <input id="gridCm" type="number" value="5" min="1" step="1" style="width:90px" />
          <span class="hint">cm</span>
        </div>
      </div>

      <div class="kv">
        <div>방 크기</div>
        <div class="row" style="margin:0">
          <div>
            <input id="roomW" type="number" value="240" min="50" step="10" style="width:90px" />
            <span class="hint">cm</span>
          </div>
          <div>
            <input id="roomH" type="number" value="200" min="50" step="10" style="width:90px" />
            <span class="hint">cm</span>
          </div>
          <button id="applyRoom">적용</button>
        </div>
      </div>

      <div class="kv">
        <div>프리셋</div>
        <div class="row" style="margin:0">
          <select id="preset" style="flex:1">
            <option value="신발장,80,30,#77e3ff">신발장 80×30</option>
            <option value="수납장,120,40,#ffd36a">수납장 120×40</option>
            <option value="벤치,90,35,#c8ff77">벤치 90×35</option>
            <option value="행거,60,60,#ff9bd6">행거 60×60</option>
            <option value="테이블,100,60,#b7a3ff">테이블 100×60</option>
          </select>
          <button id="addBtn">추가</button>
        </div>
      </div>

      <div class="row">
        <button id="rotateL">회전 -90°</button>
        <button id="rotateR">회전 +90°</button>
        <button id="deleteSel">선택 삭제</button>
      </div>

      <div class="row">
        <button id="bringFront">앞으로</button>
        <button id="sendBack">뒤로</button>
        <button id="clearAll">전체 삭제</button>
      </div>

      <div class="kv">
        <div>저장/불러오기</div>
        <div class="hint">JSON을 복사/저장해두면, 다시 붙여넣고 “불러오기”로 복원됩니다.</div>
      </div>
      <div class="row" style="margin-top:6px">
        <button id="exportBtn">내보내기(JSON)</button>
        <button id="importBtn">불러오기(JSON)</button>
      </div>
      <textarea id="jsonBox" spellcheck="false" placeholder="여기에 JSON이 표시됩니다."></textarea>

      <div class="hint" style="margin-top:10px">
        - 드래그: 이동(격자 스냅)<br/>
        - 핸들: 크기 변경 / 회전 핸들: 회전(90° 스냅)<br/>
        - 겹치거나 방 밖이면: 자동으로 되돌림(충돌 방지)<br/>
        - 단축키: Delete(삭제), 방향키(격자 단위 이동)
      </div>
    </div>

    <div class="stageWrap">
      <div class="topbar">
        클릭해서 선택 → 변형 가능
        <span class="badge" id="selInfo">선택 없음</span>
      </div>
      <div id="stage" style="margin:18px;"></div>
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);

    let stage, layer, uiLayer, transformer, roomRect;
    let selected = null;

    function num(v, def = 0) {
      const n = Number(v);
      return Number.isFinite(n) ? n : def;
    }

    function settings() {
      const pxPerCm = Math.max(1, num($("pxPerCm").value, 4));
      const gridCm = Math.max(1, num($("gridCm").value, 5));
      const roomWcm = Math.max(50, num($("roomW").value, 240));
      const roomHcm = Math.max(50, num($("roomH").value, 200));
      return { pxPerCm, gridCm, roomWcm, roomHcm };
    }

    function pxFromCm(cm) {
      const { pxPerCm } = settings();
      return cm * pxPerCm;
    }
    function cmFromPx(px) {
      const { pxPerCm } = settings();
      return px / pxPerCm;
    }

    function snap(v, gridPx) {
      return Math.round(v / gridPx) * gridPx;
    }

    function updateSelBadge() {
      $("selInfo").textContent = selected ? `${selected.getAttr("meta")?.name || "가구"} 선택됨` : "선택 없음";
    }

    function destroyStage() {
      if (stage) stage.destroy();
      stage = null; layer = null; uiLayer = null; transformer = null; roomRect = null;
      selected = null;
      $("stage").innerHTML = "";
      updateSelBadge();
    }

    function drawGrid() {
      const { gridCm } = settings();
      const gridPx = Math.max(2, Math.round(pxFromCm(gridCm)));
      layer.find(".gridLine").forEach(n => n.destroy());

      for (let x = gridPx; x < stage.width(); x += gridPx) {
        layer.add(new Konva.Line({
          points: [x, 0, x, stage.height()],
          stroke: "rgba(255,255,255,0.06)",
          strokeWidth: 1,
          name: "gridLine",
          listening: false
        }));
      }
      for (let y = gridPx; y < stage.height(); y += gridPx) {
        layer.add(new Konva.Line({
          points: [0, y, stage.width(), y],
          stroke: "rgba(255,255,255,0.06)",
          strokeWidth: 1,
          name: "gridLine",
          listening: false
        }));
      }
    }

    function initStage() {
      const { roomWcm, roomHcm } = settings();
      const w = Math.round(pxFromCm(roomWcm));
      const h = Math.round(pxFromCm(roomHcm));

      destroyStage();
      $("stage").style.width = w + "px";
      $("stage").style.height = h + "px";

      stage = new Konva.Stage({ container: "stage", width: w, height: h });
      layer = new Konva.Layer();
      uiLayer = new Konva.Layer();

      roomRect = new Konva.Rect({
        x: 0, y: 0, width: w, height: h,
        fill: "rgba(255,255,255,0.04)",
        stroke: "rgba(255,255,255,0.18)",
        strokeWidth: 2,
        cornerRadius: 14,
        listening: true
      });
      layer.add(roomRect);
      drawGrid();

      transformer = new Konva.Transformer({
        rotateEnabled: true,
        rotationSnaps: [0, 90, 180, 270],
        enabledAnchors: [
          "top-left", "top-right", "bottom-left", "bottom-right",
          "middle-left", "middle-right", "top-center", "bottom-center"
        ],
        anchorFill: "#5bd6ff",
        anchorStroke: "rgba(0,0,0,.4)",
        anchorSize: 10,
        borderStroke: "rgba(91,214,255,.9)",
        borderDash: [6, 4],
        keepRatio: false
      });
      uiLayer.add(transformer);

      stage.add(layer);
      stage.add(uiLayer);

      stage.on("mousedown touchstart", (e) => {
        if (e.target === stage || e.target === roomRect) select(null);
      });

      layer.draw();
      uiLayer.draw();
    }

    function select(node) {
      selected = node;
      transformer.nodes(node ? [node] : []);
      updateSelBadge();
      uiLayer.batchDraw();
    }

    function allFurniture() {
      return layer ? layer.find(".furniture") : [];
    }

    function getFurnitureRect(group) {
      return group.findOne(".frect");
    }

    function getFurnitureClientRect(group) {
      return group.getClientRect({ skipStroke: true, skipShadow: true });
    }

    function inRoomBounds(clientRect) {
      return (
        clientRect.x >= 0 &&
        clientRect.y >= 0 &&
        clientRect.x + clientRect.width <= stage.width() &&
        clientRect.y + clientRect.height <= stage.height()
      );
    }

    function overlapsAny(group) {
      const a = getFurnitureClientRect(group);
      const list = allFurniture();
      for (const other of list) {
        if (other === group) continue;
        const b = getFurnitureClientRect(other);
        if (Konva.Util.haveIntersection(a, b)) return true;
      }
      return false;
    }

    function rememberPrev(group) {
      const r = getFurnitureRect(group);
      group.setAttr("_prev", {
        x: group.x(),
        y: group.y(),
        rotation: group.rotation(),
        w: r.width(),
        h: r.height()
      });
    }

    function applyRectSize(group, wPx, hPx) {
      const r = getFurnitureRect(group);
      const label = group.findOne(".flabel");
      const dims = group.findOne(".fdims");

      const w = Math.max(10, wPx);
      const h = Math.max(10, hPx);

      r.width(w);
      r.height(h);
      r.x(-w / 2);
      r.y(-h / 2);

      label.x(-w / 2 + 8);
      label.y(-h / 2 + 6);

      dims.text(`${Math.round(cmFromPx(w))}×${Math.round(cmFromPx(h))}cm`);
      dims.x(-w / 2 + 8);
      dims.y(-h / 2 + 26);
    }

    function revertIfInvalid(group) {
      const prev = group.getAttr("_prev");
      if (!prev) return true;

      const rect = getFurnitureClientRect(group);
      const ok = inRoomBounds(rect) && !overlapsAny(group);
      if (ok) return true;

      const r = getFurnitureRect(group);
      group.position({ x: prev.x, y: prev.y });
      group.rotation(prev.rotation);
      applyRectSize(group, prev.w, prev.h);
      group.scale({ x: 1, y: 1 });
      layer.batchDraw();
      uiLayer.batchDraw();
      return false;
    }

    function snapGroupToGrid(group) {
      const { gridCm } = settings();
      const gridPx = Math.max(2, Math.round(pxFromCm(gridCm)));
      group.position({ x: snap(group.x(), gridPx), y: snap(group.y(), gridPx) });
    }

    function addFurnitureFromCm({ name, wCm, hCm, color, xCm, yCm, rotation }) {
      const wPx = pxFromCm(wCm);
      const hPx = pxFromCm(hCm);

      const cx = (xCm != null) ? pxFromCm(xCm) : stage.width() / 2;
      const cy = (yCm != null) ? pxFromCm(yCm) : stage.height() / 2;

      const g = new Konva.Group({
        x: cx,
        y: cy,
        draggable: true,
        name: "furniture"
      });
      g.setAttr("meta", { name, color });

      const rect = new Konva.Rect({
        x: -wPx / 2,
        y: -hPx / 2,
        width: wPx,
        height: hPx,
        fill: color,
        opacity: 0.28,
        stroke: color,
        strokeWidth: 2,
        cornerRadius: 8,
        name: "frect"
      });
      const label = new Konva.Text({
        x: -wPx / 2 + 8,
        y: -hPx / 2 + 6,
        text: name,
        fontSize: 14,
        fill: "rgba(255,255,255,.92)",
        name: "flabel"
      });
      const dims = new Konva.Text({
        x: -wPx / 2 + 8,
        y: -hPx / 2 + 26,
        text: `${Math.round(wCm)}×${Math.round(hCm)}cm`,
        fontSize: 12,
        fill: "rgba(255,255,255,.82)",
        name: "fdims"
      });

      g.add(rect);
      g.add(label);
      g.add(dims);

      if (Number.isFinite(rotation)) g.rotation(rotation);

      g.on("mousedown touchstart", (e) => {
        e.cancelBubble = true;
        select(g);
      });

      g.on("dragstart", () => rememberPrev(g));
      g.on("dragmove", () => {
        snapGroupToGrid(g);
        layer.batchDraw();
      });
      g.on("dragend", () => {
        snapGroupToGrid(g);
        revertIfInvalid(g);
      });

      g.on("transformstart", () => rememberPrev(g));
      g.on("transformend", () => {
        const r = getFurnitureRect(g);
        const newW = r.width() * g.scaleX();
        const newH = r.height() * g.scaleY();
        g.scale({ x: 1, y: 1 });
        applyRectSize(g, newW, newH);
        snapGroupToGrid(g);
        revertIfInvalid(g);
      });

      layer.add(g);
      select(g);
      rememberPrev(g);
      snapGroupToGrid(g);
      if (!revertIfInvalid(g)) {
        // 배치가 완전히 불가능한 경우만: 중앙에서 조금 이동해서 재시도
        g.position({ x: snap(stage.width() / 2 + pxFromCm(10), pxFromCm(settings().gridCm)), y: snap(stage.height() / 2, pxFromCm(settings().gridCm)) });
        revertIfInvalid(g);
      }
      layer.batchDraw();
    }

    function rotateSelected(delta) {
      if (!selected) return;
      rememberPrev(selected);
      const next = ((selected.rotation() + delta) % 360 + 360) % 360;
      // 90도 스냅
      const snapped = Math.round(next / 90) * 90;
      selected.rotation(snapped % 360);
      snapGroupToGrid(selected);
      revertIfInvalid(selected);
      layer.batchDraw();
      uiLayer.batchDraw();
    }

    function deleteSelected() {
      if (!selected) return;
      const toDel = selected;
      select(null);
      toDel.destroy();
      layer.batchDraw();
      uiLayer.batchDraw();
    }

    function exportJson() {
      const s = settings();
      const items = allFurniture().map(g => {
        const r = getFurnitureRect(g);
        const meta = g.getAttr("meta") || {};
        return {
          name: meta.name || "가구",
          color: meta.color || "#77e3ff",
          xCm: cmFromPx(g.x()),
          yCm: cmFromPx(g.y()),
          wCm: cmFromPx(r.width()),
          hCm: cmFromPx(r.height()),
          rotation: g.rotation()
        };
      });
      const payload = {
        version: 1,
        room: { wCm: s.roomWcm, hCm: s.roomHcm },
        gridCm: s.gridCm,
        pxPerCm: s.pxPerCm,
        items
      };
      $("jsonBox").value = JSON.stringify(payload, null, 2);
      $("jsonBox").focus();
      $("jsonBox").select();
    }

    function importJson() {
      let payload;
      try {
        payload = JSON.parse($("jsonBox").value || "{}");
      } catch (e) {
        alert("JSON 파싱 실패");
        return;
      }

      if (!payload || !payload.room || !Array.isArray(payload.items)) {
        alert("형식이 올바르지 않습니다.");
        return;
      }

      $("roomW").value = payload.room.wCm ?? $("roomW").value;
      $("roomH").value = payload.room.hCm ?? $("roomH").value;
      $("gridCm").value = payload.gridCm ?? $("gridCm").value;
      $("pxPerCm").value = payload.pxPerCm ?? $("pxPerCm").value;

      initStage();

      // 전체 삭제
      allFurniture().forEach(n => n.destroy());
      select(null);

      for (const it of payload.items) {
        addFurnitureFromCm({
          name: it.name,
          wCm: it.wCm,
          hCm: it.hCm,
          color: it.color,
          xCm: it.xCm,
          yCm: it.yCm,
          rotation: it.rotation
        });
      }
      layer.batchDraw();
    }

    function clearAll() {
      select(null);
      allFurniture().forEach(n => n.destroy());
      layer.batchDraw();
      uiLayer.batchDraw();
    }

    function applyRoomAndKeep() {
      const prev = $("jsonBox").value?.trim();
      exportJson();
      const exported = $("jsonBox").value;
      initStage();
      $("jsonBox").value = prev || exported; // 사용자가 입력해둔 내용은 보존
      try {
        const payload = JSON.parse(exported);
        $("jsonBox").value = exported;
        importJson();
        $("jsonBox").value = prev || exported;
      } catch {
        // ignore
      }
    }

    function bindUi() {
      $("addBtn").addEventListener("click", () => {
        const [name, w, h, color] = ($("preset").value || "").split(",");
        addFurnitureFromCm({ name, wCm: Number(w), hCm: Number(h), color });
      });
      $("rotateL").addEventListener("click", () => rotateSelected(-90));
      $("rotateR").addEventListener("click", () => rotateSelected(90));
      $("deleteSel").addEventListener("click", () => deleteSelected());
      $("bringFront").addEventListener("click", () => { if (selected) { selected.moveToTop(); layer.batchDraw(); }});
      $("sendBack").addEventListener("click", () => { if (selected) { selected.moveToBottom(); roomRect.moveToBottom(); layer.batchDraw(); }});
      $("clearAll").addEventListener("click", () => clearAll());
      $("exportBtn").addEventListener("click", () => exportJson());
      $("importBtn").addEventListener("click", () => importJson());
      $("applyRoom").addEventListener("click", () => applyRoomAndKeep());

      window.addEventListener("keydown", (e) => {
        if (!selected) return;
        const { gridCm } = settings();
        const step = Math.max(1, Math.round(pxFromCm(gridCm)));
        let moved = false;
        if (e.key === "Delete") {
          deleteSelected();
          e.preventDefault();
          return;
        }
        if (e.key === "ArrowLeft") { rememberPrev(selected); selected.x(selected.x() - step); moved = true; }
        if (e.key === "ArrowRight") { rememberPrev(selected); selected.x(selected.x() + step); moved = true; }
        if (e.key === "ArrowUp") { rememberPrev(selected); selected.y(selected.y() - step); moved = true; }
        if (e.key === "ArrowDown") { rememberPrev(selected); selected.y(selected.y() + step); moved = true; }
        if (moved) {
          snapGroupToGrid(selected);
          revertIfInvalid(selected);
          layer.batchDraw();
          e.preventDefault();
        }
      });
    }

    (function main() {
      initStage();
      bindUi();
    })();
  </script>
</body>
</html>


